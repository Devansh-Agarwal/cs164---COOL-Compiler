README file for Programming Assignment 2 (Java edition)
=======================================================

Your directory should now contain the following files:

 build.xml
 README
 cool.lex
 test.cl
 tests/*
 AbstractSymbol.java  -> [course dir]/src/PA2J/AbstractSymbol.java
 BoolConst.java       -> [course dir]/src/PA2J/BoolConst.java
 Flags.java           -> [course dir]/src/PA2J/Flags.java
 IdSymbol.java        -> [course dir]/src/PA2J/IdSymbol.java
 IdTable.java         -> [course dir]/src/PA2J/IdTable.java
 IntSymbol.java       -> [course dir]/src/PA2J/IntSymbol.java
 IntTable.java        -> [course dir]/src/PA2J/IntTable.java
 Lexer.java           -> [course dir]/src/PA2J/Lexer.java
 AbstractTable.java   -> [course dir]/src/PA2J/AbstractTable.java
 StringSymbol.java    -> [course dir]/src/PA2J/StringSymbol.java
 StringTable.java     -> [course dir]/src/PA2J/StringTable.java
 Utilities.java       -> [course dir]/src/PA2J/Utilities.java
 TokenConstants.java  -> [course dir]/src/PA2J/TokenConstants.java
 *.java		      other generated files

	The build.xml contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code. Just edit this file.

	cool.lex is a skeleton file for the specification of the
	lexical analyzer. You should complete it with your regular
	expressions, patterns and actions. Information on how to do this
	is in the jlex manual, which is part of your reader.

	test.cl is a COOL program that you can test the lexical
	analyzer on. It contains some errors, so it won't compile with
	coolc. However, test.cl does not exercise all lexical
	constructs of COOL and part of your assignment is to rewrite
	test.cl with a complete set of tests for your lexical analyzer.

        tests is a directory containing five test cases with expected outputs.
        DO NOT MODIFY.

	TokenConstants.java contains constant definitions that are used by
	almost all parts of the compiler. DO NOT MODIFY.

	*Table.java and *Symbol.java contain string table data
	structures.  DO NOT MODIFY.

	Utilities.java contains various support functions used by the
	main lexer driver (Lexer.java).  DO NOT MODIFY.

	Lexer.java contains the main method which will call your lexer
	and print out the tokens that it returns.  DO NOT MODIFY.

        CoolLexer.java is the scanner generated by jlex from cool.lex.
        DO NOT MODIFY IT, as your changes will be overritten the next
        time you run jlex.

	mycoolc is a shell script that glues together the phases of the
	compiler using Unix pipes instead of statically linking code.  
	While inefficient, this architecture makes it easy to mix and match
	the components you write with those of the course compiler.
	DO NOT MODIFY.	

Instructions
------------

	Remember to make sure `~cs164/bin' is in your `path' variable.

	To compile your lexer type:

	% ant lexer

	Run your lexer by putting your test input in a file 'foo.cl' and
	run the lextest program:

	% ./lexer foo.cl

	To run your lexer on the file test.cl type:

	% ant test

        To run five examples in tests directory type:

        % ant test-all

	If you think your lexical analyzer is correct and behaves like
	the one we wrote, you can actually try 'mycoolc' and see whether
	it runs and produces correct code for the examples and your
	first assignment. If your lexical analyzer behaves in an
	unexpected manner, you may get errors anywhere, i.e. during
	parsing, during semantic analysis, during code generation or
	only when you run the produced code on spim. So beware.

	To turnin your work type:

	% ant submit-clean

	And run the "submit" program following the instructions on the
	course web page.
	
	Running "submit" will collect the files cool.lex, test.cl,
	README, and test.output. Don't forget to edit the README file to
	include your write-up, and to write your own test cases in
	test.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA2J
-----------------
DESIGN DECISIONS

We created 4 states for our lexer, the lexer starts off in default mode known as YYINITIAL and moves on to state STRING_MODE
when a double quote is first encountered, it moves on to state LINE_COMMENT when a -- is encountered, and goes into state
BLOCK_COMMENT when a (* is encountered, and switches states depending on the lexical specification (E.g. like a '*)' for ending the block comment or an EOF in a string, etc.).

This design design for multiple states allowed us to easily think about and design regular expressions that capture how the remaining characters should be read and lexed. For example Strings have a lot of potential error cases and by having a String mode we can handle these cases with regexs that we know won't affect the program when it's in a non-STRING_MODE state, which simplifies the design of our lex file code. It also allowed us to handle EOFs differently depending on what state we were in (using a switch statement) which was another benefit of this multiple state approach.

WHY CODE IS CORRECT
A code is only correct if it is true that the tests are complete (all test cases accounted for as specified by the COOL-AID manual and project specs) and if the code passes all these tests.
Therefore my explanation for why the code is correct is that it passes our tests, and we will talk about why our tests are complete in the next section. 

We also used mycoolc on a random subset of cool files in the examples folder as a sanity check and it managed to compile them in the same way the coolc compiler compiled them so that's also reassuring that our code is most likely correct.

WHY TESTS ARE COMPLETE
We argue our tests are complete because we test all the different issues/conditions mentioned in the COOL-AID manual for lexical structure in our file test.cl (THERE ARE LINE COMMENTS GIVING TITLES FOR EACH SECTION OF TESTS IN TEST.CL FOR VISUAL CONVENIENCE):

Integers, Keywords, and Identifyers:
Integers: TESTED
type identifyers: TESTED
object identifyers: TESTED
self: TESTED
SELF_TYPE: TESTED
keywords: TESTED

Strings:
Within a string, a sequence ‘\c’ denotes the character ‘c’,
with the exception of the following: \b \t \n \f : TESTED
A non-escaped newline character may not appear in a string ok case: TESTED
A non-escaped newline character may not appear in a string not ok case: TESTED
A string may not contain EOF:TESTED 
A string may not contain the null (character \0): TESTED 
Any other character may be included in a string: PRETTY MUCH TESTED

Comments:
Line Comments:
Any characters between two dashes “--” and the next newline as comments: TESTED
Any characters between two dashes “--” and the EOF as comments: TESTED
Block Comments:
Comments may also be written by enclosing text in (∗ . . . ∗):TESTED 
The latter form of comment may be nested: TESTED

Whitespace:
White space consists of any sequence of the characters: blank (ascii 32), \n (newline, ascii 10), \f (form
feed, ascii 12), \r (carriage return, ascii 13), \t (tab, ascii 9), \v (vertical tab, ascii 11): TESTED

Also our lexer passed all the tests in the tests folder as well, so we're pretty sure our program is correct.