README file for Programming Assignment 3 (Java edition)
=======================================================

Your directory should now contain the following files:

 build.xml
 README
 cool.cup
 bad.cl
 good.cl
 compare-parser           -> [course dir]/src/PA3J/compare-parser
 myparser                 -> [course dir]/src/PA3J/myparser
 ref-parser               -> [course dir]/src/PA3J/ref-parser
 mycoolc                  -> [course dir]/src/PA3J/mycoolc
 cool-tree.java		  -> [course dir]/src/PA3J/cool-tree.java
 cool-tree.aps		  -> [course dir]/src/PA3J/cool-tree.aps
 AbstractSymbol.java	  -> [course dir]/src/PA3J/AbstractSymbol.java
 AbstractTable.java	  -> [course dir]/src/PA3J/AbstractTable.java
 BoolConst.java		  -> [course dir]/src/PA3J/BoolConst.java
 CgenClassTable.java	  -> [course dir]/src/PA3J/CgenClassTable.java
 CgenNode.java		  -> [course dir]/src/PA3J/CgenNode.java
 CgenSupport.java	  -> [course dir]/src/PA3J/CgenSupport.java
 ClassTable.java	  -> [course dir]/src/PA3J/ClassTable.java
 CoolParser.java	  -> [course dir]/src/PA3J/CoolParser.java
 CoolTokenLexer.java	  -> [course dir]/src/PA3J/CoolTokenLexer.java
 Flags.java		  -> [course dir]/src/PA3J/Flags.java
 IdSymbol.java		  -> [course dir]/src/PA3J/IdSymbol.java
 IdTable.java		  -> [course dir]/src/PA3J/IdTable.java
 IntSymbol.java		  -> [course dir]/src/PA3J/IntSymbol.java
 IntTable.java		  -> [course dir]/src/PA3J/IntTable.java
 ListNode.java		  -> [course dir]/src/PA3J/ListNode.java
 Parser.java		  -> [course dir]/src/PA3J/Parser.java
 StringSymbol.java	  -> [course dir]/src/PA3J/StringSymbol.java
 StringTable.java	  -> [course dir]/src/PA3J/StringTable.java
 SymbolTable.java	  -> [course dir]/src/PA3J/SymbolTable.java
 TokenConstants.java	  -> [course dir]/src/PA3J/TokenConstants.java
 TreeConstants.java	  -> [course dir]/src/PA3J/TreeConstants.java
 TreeNode.java		  -> [course dir]/src/PA3J/TreeNode.java
 Utilities.java		  -> [course dir]/src/PA3J/Utilities.java
 *.java			  other generated files

	The build.xml contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.cup is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the CUP documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).  From
	this file, cool-tree.java is automatically generated by a
	utility that compiles the specification into Java classes for
	constructing tree nodes.  This file is provided for your
	reference.  DO NOT MODIFY.

        TreeNode.java and ListNode.java contain definitions used by the
        tree package. DO NOT MODIFY.  

        Parser.java contains a driver to test the parser. DO NOT MODIFY.

	Flags.java implements routines for parsing command line
	flags. DO NOT MODIFY.

        tests is a directory containing ten test cases with expected outputs.
        DO NOT MODIFY.

        The rest of the files are created as byproducts of `CUP', or
        are internal parser support files.  DO NOT MODIFY.
        `CoolParser.java' is the generated Java file containing the
        parser.  DO NOT MODIFY this file directly; instead, edit
        cool.cup and this file will be regenerated automatically.

	Files not discussed are covered in the README for PA2J.

Instructions
------------

	To compile your parser program type:

	% ant parser

	This compiles all the classes and produces an shell script named
	"parser" which invokes Parser.main() as the standalone phase of
	the Cool compiler.  It requires lexer, semant, and cgen to do
	anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.  Don't worry if the line numbers you get by
	running Java version of the parser are slightly off as compared
	to the "official" parser.

	To run your parser on the files good.cl and bad.cl type:

	% ant test

        To run ten examples in tests directory type:

        % ant test-all

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

        To run the reference parser on a file 'fool.cl':

        % ref-parser foo.cl

        To easily compare your parser and the reference parser:

        % compare-parser foo.cl

        This will create two files: foo.cl.out.my and foo.cl.out.ref

	To turn in your work type:

	% ant submit-clean

	And run the "submit PA3" program. This will automatically collect the
	files good.cl, bad.cl, good.output, bad.output, README, and cool.cup 
        file. Don't forget to edit this README file to include your write-up, 
        and to write your own test cases in good.cl and bad.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3J
-----------------
Thorough discussion of design decisions (e.g., the handling of let) and choice of test cases;
a few paragraphs of coherent English sentences should be fine

Design Decisions:

1. Using 'list'-like helper grammars to deal with arbitrarily sized lists (features, formals, etc.)
   The use of helper lists clearly makes it easy to deal with optional lists of arguments, features, etc.

   e.g. 
   /* feature lists and features */
optional_feature_list
	/* single feature */
	::= feature:f
		{: //System.err.println("Reached first feature list production");
			RESULT = new Features(curr_lineno()).appendElement(f);:}
	/* several features */
	| optional_feature_list:ofl feature:f
		{: //System.err.println("Reached second feature list production");
			RESULT = ofl.appendElement(f); :}
	/* no features */
	| /* empty */
	    {: //System.err.println("Reached third feature list production");
	    	RESULT = new Features(curr_lineno()); :}
	;

2. Giving all operators a precedence
   /*Order is lowest precedence top and highest predence bottom */
   precedence right ASSIGN;
   precedence right NOT;     
   precedence nonassoc LE, LT, EQ;
   precedence left PLUS, MINUS;
   precedence left MULT, DIV;
   precedence right ISVOID;  
   precedence right NEG;     
   precedence nonassoc AT;   
   precedence left DOT;      

   Normally overusing precedence can lead to undesirable trees, but we never encounted any shift-reduce or reduce-reduce
   errors during anytime of our development because of these precedence declaration, and when we compared our parsers with the reference parser and we hade the same output on all our tests files, the test folder files, and all files in the examples folder with
   the exception of the following: all the *_exceptions.cl files in the examples folder and null_string.cl file in the 
   examples folder. We are currently unsure as to why those files didn't work but all the other files did.
   But we did notice even the coolc compiler failed to compile some of those files so I believe it could just be
   some super obscure bug or even a problem with that cool file. So we are confident with our compiler overall.

3. Following the COOL CFG in the Manual and PA3 doc
   Basically We meticulously made sure our cup grammar matched that of the spec, which is an obvious design decision haha.
   And we do error handling as described in the PA3 doc

4. Handling of Let
    Our design decision was to handle let via a recursive function we defined in the action code section of the cup file:

    let createLet(int line_no, Features features, Expression e, int counter){
    	if(counter == features.getLength()-1){
    		return new let(curr_lineno(), ((attr) features.getNth(counter)).name, ((attr) features.getNth(counter)).type_decl,
    			((attr) features.getNth(counter)).init, e);
    	}else {
    		return new let(curr_lineno(), ((attr) features.getNth(counter)).name, ((attr) features.getNth(counter)).type_decl,
    			((attr) features.getNth(counter)).init, createLet(line_no, features, e, ++counter));
    	}
    }

    Thus in the LET part for our expression:

    | LET let_attr_list:l IN expr:e
		{: RESULT = createLet(curr_lineno(), l, e, 0); :}

    And the helpers:

    /* let subexpression */
let_attr_list
	::= let_attr:f
		{: //System.err.println("Reached first feature list production");
			RESULT = new Features(curr_lineno()).appendElement(f);:}
	/* several features */
	| let_attr_list:ltl COMMA let_attr:f
		{: //System.err.println("Reached second feature list production");
			RESULT = ltl.appendElement(f); :}
	;

	let_attr
	::= OBJECTID:o COLON TYPEID:t ASSIGN expr:e
		{: //System.err.println("Reached first attr feature production");
			RESULT = new attr(curr_lineno(), o, t, e);:}
	| OBJECTID:o COLON TYPEID:t
		{: //System.err.println("Reached second attr feature production");
			RESULT = new attr(curr_lineno(), o, t, new no_expr(curr_lineno()));:}
	| error
	    {: //System.err.println("Reached program error production");
	    	RESULT = new attr(curr_lineno(), AbstractTable.idtable.addString("self"),
	    		                  AbstractTable.idtable.addString("Object"),
	    		                  new no_expr(curr_lineno())); :}
	;


	This design decision allowed us to convert the let list into the nested let trees so in complys with
	cools definition of let.